<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Random Thoughts]]></title>
  <link href="http://imurchie.github.io/blog/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://imurchie.github.io/blog/"/>
  <updated>2013-12-04T08:17:14-08:00</updated>
  <id>http://imurchie.github.io/blog/</id>
  <author>
    <name><![CDATA[Isaac Murchie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Singleton Classes]]></title>
    <link href="http://imurchie.github.io/blog/blog/2013/12/04/singleton/"/>
    <updated>2013-12-04T08:14:17-08:00</updated>
    <id>http://imurchie.github.io/blog/blog/2013/12/04/singleton</id>
    <content type="html"><![CDATA[<p>Exploring metaprogramming in Ruby has been very interesting, and I’ve only begun to scratch the surface. And the central feature in that thin strip is the “singleton class” (not to be confused with the <a href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton Pattern</a>, which is implemented in Ruby with the <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/singleton/rdoc/Singleton.html"><code>Singleton</code> module</a>), also known as the “Eigenclass,” “Ghost Class,” “Metaclass” or “Uniclass.”</p>

<!-- more -->

<p>This class is an anonymous class into which methods defined upon an object (i.e., an instance of a class) are defined. Normal methods are defined on a class, which allows for those methods to be shared by every instance of the class (and subclasses):</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre><span class="keyword">class</span> <span class="class">Test</span>
  <span class="keyword">def</span> <span class="function">initialize</span>(name = <span class="string"><span class="delimiter">&quot;</span><span class="content">Test</span><span class="delimiter">&quot;</span></span>)
    <span class="instance-variable">@name</span> = name
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">name</span>
    <span class="instance-variable">@name</span>.capitalize
  <span class="keyword">end</span>
<span class="keyword">end</span>
</pre></td>
</tr></table>
</div>

<p>When this class is instantiated those instances will each have a copy of their instance variables (in this case, <code>@name</code>), but will all share the instance methods, <code>#initialize</code> and <code>#name</code>, living in the <code>Test</code> class.</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
</pre></td>
  <td class="code"><pre>one = <span class="constant">Test</span>.new(<span class="string"><span class="delimiter">&quot;</span><span class="content">instance one</span><span class="delimiter">&quot;</span></span>)
two = <span class="constant">Test</span>.new(<span class="string"><span class="delimiter">&quot;</span><span class="content">instance two</span><span class="delimiter">&quot;</span></span>)

puts one.name
<span class="comment"># =&gt; Instance one</span>

puts two.name
<span class="comment"># =&gt; Instance two</span>
</pre></td>
</tr></table>
</div>

<p>If we reopen the class (monkeypatch it) the method(s) we add will be available to all the instances:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
</pre></td>
  <td class="code"><pre><span class="keyword">class</span> <span class="class">Test</span>
  <span class="keyword">def</span> <span class="function">name_weird</span>
    <span class="instance-variable">@name</span>.chars.each_with_index.map { |c, i| i.even? ? c : c.swapcase }.join
  <span class="keyword">end</span>
<span class="keyword">end</span>

puts one.name_weird
<span class="comment"># =&gt; iNsTaNcE OnE</span>

puts two.name_weird
<span class="comment"># =&gt; iNsTaNcE TwO</span>
</pre></td>
</tr></table>
</div>

<p>But it is also possible to add a method to a particular instance of the class:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> one.<span class="function">name_one</span>
  <span class="instance-variable">@name</span>.upcase
<span class="keyword">end</span>

puts one.name_one
<span class="comment"># =&gt; INSTANCE ONE</span>

puts two.name_one
<span class="comment"># =&gt; NoMethodError: undefined method `name_one' for #&lt;Test:... @name=&quot;instance two&quot;&gt;</span>
<span class="comment"># =&gt; ...</span>
</pre></td>
</tr></table>
</div>

<p>Where does this method live? In the Eigenclass! (Side note: I’m going to use “Eigenclass” here, since it obviates the confusion with the Singleton Pattern, despite its sounding somewhat poncy.) The usually anonymous Eigenclass can be gotten relatively easily:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre>eigenclass = <span class="keyword">class</span> &lt;&lt; <span class="class">one</span>
  <span class="predefined-constant">self</span>
<span class="keyword">end</span>

puts eigenclass
<span class="comment"># =&gt; #&lt;Class:#&lt;Test:0x007f93735a7e50&gt;&gt;</span>

puts eigenclass.class
<span class="comment"># =&gt; Class</span>
</pre></td>
</tr></table>
</div>

<p>The methods can then be seen:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
</pre></td>
  <td class="code"><pre><span class="comment"># methods on the class</span>
puts <span class="constant">Test</span>.instance_methods(<span class="predefined-constant">false</span>)
<span class="comment"># =&gt; [:name]</span>


<span class="comment"># first instance</span>

<span class="comment"># methods starting with &quot;name&quot; on this instance (defined on it, or its parents)</span>
puts one.methods.grep(<span class="regexp"><span class="delimiter">/</span><span class="content">name.*</span><span class="delimiter">/</span></span>)
<span class="comment"># =&gt; [:name_one, :name]</span>

<span class="comment"># the methods on this particular instance but not parents</span>
puts one.methods(<span class="predefined-constant">false</span>)
<span class="comment"># =&gt; [:name_one]</span>


<span class="comment"># other instance</span>

<span class="comment"># methods starting with &quot;name&quot; on this instance (defined on it, or its parents)</span>
puts two.methods.grep(<span class="regexp"><span class="delimiter">/</span><span class="content">name.*</span><span class="delimiter">/</span></span>)
<span class="comment"># =&gt; [:name_one, :name]</span>

<span class="comment"># methods on the instance itself</span>
puts two.methods(<span class="predefined-constant">false</span>)
<span class="comment"># =&gt; []</span>
</pre></td>
</tr></table>
</div>

<p>All this is very interesting! And provides much insight into the object model for Ruby. More on this in the future. For the moment, we have an anonymous Eigenclass in which reside methods defined on an instance, providing <em>real</em> privacy (unlike the “privacy” offered by the <code>private</code> and <code>protected</code> methods). We can get the method out of the instance, but we cannot bind it to another object:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
</pre></td>
  <td class="code"><pre>meth = one.method(<span class="symbol">:name_one</span>)
meth.unbind

meth.bind(two)
<span class="comment"># =&gt; TypeError: singleton method called for a different object</span>
</pre></td>
</tr></table>
</div>

<p>So the Eigenclass of one object is an entirely different class, even when sharing a class hierarchy. This includes the Eigenclass of two:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
</pre></td>
  <td class="code"><pre>eigenclass_two = <span class="keyword">class</span> &lt;&lt; <span class="class">two</span>; <span class="predefined-constant">self</span>; <span class="keyword">end</span>

meth.bind(eigenclass_two)
<span class="comment"># =&gt; TypeError: singleton method called for a different object</span>
</pre></td>
</tr></table>
</div>

<p>The final note about the Eigenclass is that, unlike a normal class, it cannot be instantiated:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>obj = eigenclass.new
<span class="comment"># =&gt; TypeError: can't create instance of singleton class</span>
<span class="comment"># =&gt; ...</span>
</pre></td>
</tr></table>
</div>

<p>One further note to be made is the primary instance of Eigenclasses and singleton methods in Ruby, one that we use all the time without knowing it: the class method. All classes we define are instance of <a href="http://www.ruby-doc.org/core-1.9.3/Class.html"><code>Class</code></a>, into which we define methods for that particular instance. If we look at how the method was added to the instance of <code>Test</code>, <code>one</code>, we did it by using the instance as the receiver of the method definition:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> one.<span class="function">name_one</span>
  <span class="instance-variable">@name</span>.upcase
<span class="keyword">end</span>
</pre></td>
</tr></table>
</div>

<p>But this is just like the class method definition, which can be done three ways:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
</pre></td>
  <td class="code"><pre><span class="comment"># reopen the class</span>
<span class="keyword">class</span> <span class="class">Test</span>
  <span class="keyword">def</span> <span class="constant">Test</span>.<span class="function">class_method</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">this is a class method using the class name</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="predefined-constant">self</span>.<span class="function">other_class_method</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">this is a class method using self</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>

  <span class="keyword">class</span> &lt;&lt; <span class="class">self</span>
    <span class="keyword">def</span> <span class="function">further_class_method</span>
      <span class="string"><span class="delimiter">&quot;</span><span class="content">this is a class method directly on the eigenclass</span><span class="delimiter">&quot;</span></span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
</pre></td>
</tr></table>
</div>

<p>We could do all the tests above and it would come out similarly. The class <code>Class</code> is unaffected by these methods. Other classes can’t access them. Absolutely.</p>

<p>Instance methods, on the other hand, I’m still attempting to figure out.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Embedded Ruby and HTML Production]]></title>
    <link href="http://imurchie.github.io/blog/blog/2013/12/04/erb/"/>
    <updated>2013-12-04T08:10:18-08:00</updated>
    <id>http://imurchie.github.io/blog/blog/2013/12/04/erb</id>
    <content type="html"><![CDATA[<p>The funny thing about creating basic html forms and tables is that it makes the internet seem like it is 1997. After we stopped using Lynx or the command-line Mozilla, but before stylesheets gained acceptance. All we need is some animated gifs and multicolored text to induce our Geocities nightmares.</p>

<p>But seriously.</p>

<p>After generating JSON from our controllers, it feels nice to get to views and the creation of HTML. We’re using Embedded Ruby (ERB) which got me thinking about the technology.</p>

<!-- more -->

<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/erb/rdoc/ERB.html"><code>ERB</code></a> is part of the Ruby standard library, available to whatever programs might want to process templates:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
</pre></td>
  <td class="code"><pre><span class="comment"># template.erb</span>
Hello! <span class="constant">I</span> am just a regular file, with tags <span class="keyword">for</span> inserting things.

This is <span class="key">one</span>: &lt;<span class="string"><span class="delimiter">%=</span><span class="content"> name %&gt;
And another: &lt;%</span><span class="delimiter">=</span></span> statement <span class="string"><span class="delimiter">%&gt;</span><span class="content">
</span></span></pre></td>
</tr></table>
</div>

<p>The contents of the file are sent to the <code>ERB</code> class:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
</pre></td>
  <td class="code"><pre><span class="comment"># processing_erb.rb</span>
require <span class="string"><span class="delimiter">&quot;</span><span class="content">erb</span><span class="delimiter">&quot;</span></span>

template = <span class="constant">File</span>.read(<span class="string"><span class="delimiter">&quot;</span><span class="content">template.erb</span><span class="delimiter">&quot;</span></span>)
erb = <span class="constant">ERB</span>.new(template)
</pre></td>
</tr></table>
</div>

<p>There are other arguments we could send in (e.g., the “safe level” at which it should be run, etc.) but we will ignore them for now. At this point the initializer sends the source to the <code>ERB::Compiler</code> whose job it is to take the string and generate Ruby code for it:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
</pre></td>
  <td class="code"><pre><span class="comment"># lib/erb.rb</span>
<span class="keyword">def</span> <span class="function">initialize</span>(str, safe_level=<span class="predefined-constant">nil</span>, trim_mode=<span class="predefined-constant">nil</span>, eoutvar=<span class="string"><span class="delimiter">'</span><span class="content">_erbout</span><span class="delimiter">'</span></span>)
  <span class="instance-variable">@safe_level</span> = safe_level
  compiler = <span class="constant">ERB</span>::<span class="constant">Compiler</span>.new(trim_mode)
  set_eoutvar(compiler, eoutvar)
  <span class="instance-variable">@src</span>, <span class="instance-variable">@enc</span> = *compiler.compile(str)
  <span class="instance-variable">@filename</span> = <span class="predefined-constant">nil</span>
<span class="keyword">end</span>
</pre></td>
</tr></table>
</div>

<p>The compiler basically reads each token from the source template, and produces <code>print</code> statements for all the non-embedded parts which are pushed into a buffer. The opening embedding tags are pushed into a stack. When it gets to a closing embedding tag it pushes the contents between the tags into the output buffer, either bare (for <code>&lt;% ... %&gt;</code>) or capturing and <code>print</code>ing the output (for <code>&lt;%= ... %&gt;</code>).</p>

<p>The compiler returns an array, with the template-cum-code first, then the encoding of the string passed in. So, for <code>template.erb</code> above, we get:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
</pre></td>
  <td class="code"><pre><span class="comment"># processing_erb.rb</span>
compiler = <span class="constant">ERB</span>::<span class="constant">Compiler</span>.new(<span class="predefined-constant">nil</span>)
code, encoding = compiler.compiler(template)

puts code
<span class="comment"># =&gt; print &quot;Hello! I am just a regular file, with tags for inserting things.\nThis is one: &quot;</span>
<span class="comment"># =&gt; ; print(( name ).to_s); print &quot;\nAnd another: &quot;</span>
<span class="comment"># =&gt; ; print(( statement ).to_s)</span>

puts encoding
<span class="comment"># =&gt; UTF-8</span>
</pre></td>
</tr></table>
</div>

<p>We can see, then, what is needed in terms of data: the two local variables. We could have embedded any sort of variable (i.e., instance, class instance, class, global) and we would have gotten those in the compiled code. Indeed, the <code>ERB::Compiler#compile</code> method <em>does not care</em> what is in there. It does not check if it is valid Ruby when it creates the “code” string.</p>

<p>When we call <code>ERB#result</code> or its alias, <code>ERB#run</code>, the code compile above is executed using <a href="http://ruby-doc.org/core-1.9.3/Kernel.html#method-i-exec"><code>Kernel#exec</code></a>. At this point if there are invalid Ruby statements it will fail, as well as if there are unscoped variables.</p>

<p>The variables themselves are provided by a <a href="http://www.ruby-doc.org/core-1.9.3/Binding.html"><code>Binding</code></a> (or a <a href="http://www.ruby-doc.org/core-1.9.3/Proc.html"><code>Proc</code></a>, though we will ignore that at the moment). So we can run the same template with different bindings, if for instance we wanted to process many different versions of the text (thinking, for instance, of an email template that we want to send to a number of users, say):</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
</pre></td>
  <td class="code"><pre><span class="comment"># processing_erb.rb</span>
puts erb.result(binding) <span class="comment"># use the local binding</span>
<span class="comment"># =&gt; NameError: undefined local variable or method `name' for main:Object</span>
<span class="comment"># =&gt; ...</span>

<span class="comment"># create the local variables</span>
name = <span class="string"><span class="delimiter">&quot;</span><span class="content">Isaac</span><span class="delimiter">&quot;</span></span>
statement = <span class="string"><span class="delimiter">&quot;</span><span class="content">Yay!</span><span class="delimiter">&quot;</span></span>

puts erb.result(binding)
<span class="comment"># =&gt; Hello! I am just a regular file, with tags for inserting things.</span>
<span class="comment"># =&gt;</span>
<span class="comment"># =&gt; This is one: Isaac</span>
<span class="comment"># =&gt; And another: Yay!</span>


<span class="comment"># get another scope</span>
<span class="keyword">def</span> <span class="function">test_scope_binding</span>
  name = <span class="string"><span class="delimiter">&quot;</span><span class="content">Usurper</span><span class="delimiter">&quot;</span></span>
  statement = <span class="string"><span class="delimiter">&quot;</span><span class="content">Pwned!</span><span class="delimiter">&quot;</span></span>
  binding
<span class="keyword">end</span>

puts erb.result(test_scope_binding)
<span class="comment"># =&gt; Hello! I am just a regular file, with tags for inserting things.</span>
<span class="comment"># =&gt;</span>
<span class="comment"># =&gt; This is one: Usurper</span>
<span class="comment"># =&gt; And another: Pwned!</span>
</pre></td>
</tr></table>
</div>

<p>The real functionality comes out when we provide other bindings. Since bindings are just objects, then can be passed around, and stored (though we should be careful, since the encapsulate a local scope, and so can keep objects in memory, unavailable to be garbage collected). We can do something like</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
</pre></td>
  <td class="code"><pre><span class="keyword">def</span> <span class="function">peanut_gallery_1</span>
  name = <span class="string"><span class="delimiter">&quot;</span><span class="content">Waldorf</span><span class="delimiter">&quot;</span></span>
  statement = <span class="string"><span class="delimiter">&quot;</span><span class="content">They aren’t half bad.</span><span class="delimiter">&quot;</span></span>
  binding
<span class="keyword">end</span>

<span class="keyword">def</span> <span class="function">peanut_gallery_2</span>
  name = <span class="string"><span class="delimiter">&quot;</span><span class="content">Statler</span><span class="delimiter">&quot;</span></span>
  statement = <span class="string"><span class="delimiter">&quot;</span><span class="content">Nope, they’re ALL bad!</span><span class="delimiter">&quot;</span></span>
  binding
<span class="keyword">end</span>


[peanut_gallery_1, peanut_gallery_2].each <span class="keyword">do</span> |muppet|
  puts erb.result(muppet)
<span class="keyword">end</span>
<span class="comment"># =&gt; Hello! I am just a regular file, with tags for inserting things.</span>
<span class="comment"># =&gt;</span>
<span class="comment"># =&gt; This is one: Waldorf</span>
<span class="comment"># =&gt; And another: They aren’t half bad.</span>
<span class="comment"># =&gt; Hello! I am just a regular file, with tags for inserting things.</span>
<span class="comment"># =&gt;</span>
<span class="comment"># =&gt; This is one: Statler</span>
<span class="comment"># =&gt; And another: Nope, they’re ALL bad!</span>
</pre></td>
</tr></table>
</div>

<p>Overall, then, the ERB functionality is fairly simple. Take a template, go through it to make the code that would produce that template, and then run that code in a given context. This is precisely what Rails does with its default views templating system! The context includes all the instance variables in a given controller, which are then available to the view! So:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
</pre></td>
  <td class="code"><pre><span class="comment"># app/controllers/users_controller.rb</span>
<span class="keyword">class</span> <span class="class">UsersController</span> &lt; <span class="constant">ApplicationController</span>
  <span class="keyword">def</span> <span class="function">index</span>
    <span class="instance-variable">@users</span> = <span class="constant">User</span>.all
    render <span class="symbol">:index</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment"># app/views/users/index.html.erb</span>
<span class="constant">All</span> <span class="key">users</span>:
&lt;<span class="string"><span class="delimiter">% </span><span class="content">@users.each</span><span class="delimiter"> </span></span><span class="keyword">do</span> |user| <span class="string"><span class="delimiter">%&gt;</span><span class="content">
  &lt;%= user.name %</span><span class="delimiter">&gt;</span></span>&lt;br&gt;
  &lt;<span class="string"><span class="delimiter">%=</span><span class="content"> user.email %&gt;
&lt;% end %&gt;
</span></span></pre></td>
</tr></table>
</div>

<p>And we get the output we want: dynamically populated pages! (And alliteration!)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Method Lookup in Ruby]]></title>
    <link href="http://imurchie.github.io/blog/blog/2013/12/03/methods/"/>
    <updated>2013-12-03T09:03:18-08:00</updated>
    <id>http://imurchie.github.io/blog/blog/2013/12/03/methods</id>
    <content type="html"><![CDATA[<p>When a message is sent to an object it needs to be interpretted. If sent without an explicit receiver, Ruby first looks for a variable in scope with that name. Then it moves to the current object (what is currently pointed to by <code>self</code>) and looks for a method:</p>

<!-- more -->

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
</pre></td>
  <td class="code"><pre><span class="keyword">class</span> <span class="class">Test</span>
  <span class="keyword">def</span> <span class="function">test</span>
    name = <span class="integer">1</span>

    name
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">test</span>
    name
  <span class="keyword">end</span>

  <span class="keyword">def</span> <span class="function">name</span>
    <span class="integer">2</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

test_obj = <span class="constant">Test</span>.new
</pre></td>
</tr></table>
</div>

<p>Calling <code>Test#test</code> will return 1, since there is a variable in the local scope with the name <code>name</code>.</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>puts test_obj.test
<span class="comment"># =&gt; 1</span>
</pre></td>
</tr></table>
</div>

<p>But calling <code>Test#test2</code> will return 2, as there is nothing in scope with that name, so the method <code>Test#name</code> is looked for, and found:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>puts test_obj.test2
<span class="comment"># =&gt; 2</span>
</pre></td>
</tr></table>
</div>

<p>But how is the lookup done? Where does Ruby try to find the method, and what happens when it cannot find one? The basic answer is that it looks in the class of the object receiving the message (<code>Test</code>, in the case of <code>test_obj</code>, above). If it is not found there it goes up the ancestor chain. In the case of <code>Test</code>, this means the default superclass, <a href="http://ruby-doc.org/core-1.9.3/Object.html"><code>Object</code></a>, and its superclass, <a href="http://ruby-doc.org/core-1.9.3/BasicObject.html"><code>BasicObject</code></a>.</p>

<p>If the method is not found in the class or any of its ancestors, Ruby begins to look for <code>#method_missing</code>. This lookup follows the same procedure as the original method lookup, except that the method is defined on <a href="http://ruby-doc.org/core-1.9.3/BasicObject.html#method-i-method_missing"><code>BasicObject</code></a> so it will always eventually, at the very end of the ancestor chain. This final method just raises a <a href="http://ruby-doc.org/core-1.9.3/NoMethodError.html"><code>NoMethodError</code></a> (source from <a href="https://github.com/ruby/ruby/blob/ruby_1_9_3/vm_eval.c">vm_eval.c</a>):</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre>static <span class="constant">VALUE</span>
rb_method_missing(int argc, const <span class="constant">VALUE</span> *argv, <span class="constant">VALUE</span> obj) {
  rb_thread_t *th = GET_THREAD();
  raise_method_missing(th, argc, argv, obj, th-&gt;method_missing_reason);
  <span class="keyword">return</span> <span class="constant">Qnil</span>;                <span class="regexp"><span class="delimiter">/</span><span class="content">* not reached *</span><span class="delimiter">/</span></span>
}
</pre></td>
</tr></table>
</div>

<p>Now that we have the basics, what happens when things are more complex? What about module mixins? What about singleton methods?</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
</pre></td>
  <td class="code"><pre><span class="keyword">class</span> <span class="class">A</span>
  <span class="keyword">def</span> <span class="function">test</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Instance method of class A</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>


a = <span class="constant">A</span>.new
puts a.test
<span class="comment"># =&gt; &quot;Instance method of class A&quot;</span>
</pre></td>
</tr></table>
</div>

<p>This is as we expect given the understanding above. Now let’s add some modules to the mix:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
</pre></td>
  <td class="code"><pre><span class="keyword">module</span> <span class="class">M</span>
  <span class="keyword">def</span> <span class="function">test</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Mixin method of module M</span><span class="char">\n</span><span class="inline"><span class="inline-delimiter">#{</span><span class="keyword">super</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">module</span> <span class="class">N</span>
  <span class="keyword">def</span> <span class="function">test</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Mixin method of module N</span><span class="char">\n</span><span class="inline"><span class="inline-delimiter">#{</span><span class="keyword">super</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">class</span> <span class="class">B</span> &lt; <span class="constant">A</span>
  include <span class="constant">M</span>
  include <span class="constant">N</span>

  <span class="keyword">def</span> <span class="function">test</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Instance method of class B</span><span class="char">\n</span><span class="inline"><span class="inline-delimiter">#{</span><span class="keyword">super</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>


b = <span class="constant">B</span>.new
puts b.test
<span class="comment"># =&gt; Instance method of class B</span>
<span class="comment"># =&gt; Mixin method of module N</span>
<span class="comment"># =&gt; Mixin method of module M</span>
<span class="comment"># =&gt; Instance method of class A</span>
</pre></td>
</tr></table>
</div>

<p>This shows us that modules mixed into a class are lower on the chain than instance methods, and that they are added to the chain in the order in which they are included in the class.</p>

<p>The next thing to try is to mix modules directly into the object, through the <a href="http://ruby-doc.org/core-1.9.3/Object.html#method-i-extend"><code>Object#extend</code></a> method:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
</pre></td>
  <td class="code"><pre><span class="keyword">module</span> <span class="class">O</span>
  <span class="keyword">def</span> <span class="function">test</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Mixin method of module O</span><span class="char">\n</span><span class="inline"><span class="inline-delimiter">#{</span><span class="keyword">super</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">module</span> <span class="class">P</span>
  <span class="keyword">def</span> <span class="function">test</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Mixin method of module P</span><span class="char">\n</span><span class="inline"><span class="inline-delimiter">#{</span><span class="keyword">super</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

b.extend(<span class="constant">O</span>)
b.extend(<span class="constant">P</span>)


puts b.test
<span class="comment"># =&gt; Mixin method of module P</span>
<span class="comment"># =&gt; Mixin method of module O</span>
<span class="comment"># =&gt; Instance method of class B</span>
<span class="comment"># =&gt; Mixin method of module N</span>
<span class="comment"># =&gt; Mixin method of module M</span>
<span class="comment"># =&gt; Instance method of class A</span>
</pre></td>
</tr></table>
</div>

<p>Modules mixed into objects, then, act like those on the class, but supercede the instance methods.</p>

<p>What, then, about <em>methods</em> defined on the object itself?</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
</pre></td>
  <td class="code"><pre><span class="keyword">class</span> &lt;&lt; <span class="class">b</span>
  <span class="keyword">def</span> <span class="function">test</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Singleton method of object b</span><span class="char">\n</span><span class="inline"><span class="inline-delimiter">#{</span><span class="keyword">super</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>


puts b.test
<span class="comment"># =&gt; Singleton method of object b</span>
<span class="comment"># =&gt; Mixin method of module P</span>
<span class="comment"># =&gt; Mixin method of module O</span>
<span class="comment"># =&gt; Instance method of class B</span>
<span class="comment"># =&gt; Mixin method of module N</span>
<span class="comment"># =&gt; Mixin method of module M</span>
<span class="comment"># =&gt; Instance method of class A</span>
</pre></td>
</tr></table>
</div>

<p>As we would expect, the singleton method sits at the head of the chain. But is this absolute, or just a consequence of defining it <em>after</em> having mixed in the modules?</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
</pre></td>
  <td class="code"><pre><span class="keyword">module</span> <span class="class">Q</span>
  <span class="keyword">def</span> <span class="function">test</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Mixin method of module Q</span><span class="char">\n</span><span class="inline"><span class="inline-delimiter">#{</span><span class="keyword">super</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">module</span> <span class="class">R</span>
  <span class="keyword">def</span> <span class="function">test</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Mixin method of module R</span><span class="char">\n</span><span class="inline"><span class="inline-delimiter">#{</span><span class="keyword">super</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

b.extend(<span class="constant">Q</span>)
b.extend(<span class="constant">R</span>)


puts b.test
<span class="comment"># =&gt; Singleton method of object b</span>
<span class="comment"># =&gt; Mixin method of module R</span>
<span class="comment"># =&gt; Mixin method of module Q</span>
<span class="comment"># =&gt; Mixin method of module P</span>
<span class="comment"># =&gt; Mixin method of module O</span>
<span class="comment"># =&gt; Instance method of class B</span>
<span class="comment"># =&gt; Mixin method of module N</span>
<span class="comment"># =&gt; Mixin method of module M</span>
<span class="comment"># =&gt; Instance method of class A</span>
</pre></td>
</tr></table>
</div>

<p>Exciting! The singleton method stays at the top of the chain, the first place that is searched when attempting to find a method. As an aside, and just to drive home the… um… singularity… of singleton methods, if we define a singleton method on object <code>a</code> that method will <em>not</em> be called when using <code>b</code>:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
</pre></td>
  <td class="code"><pre>a.instance_eval <span class="keyword">do</span>
  <span class="keyword">def</span> <span class="function">test</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Singleton method of object a</span><span class="char">\n</span><span class="inline"><span class="inline-delimiter">#{</span><span class="keyword">super</span><span class="inline-delimiter">}</span></span><span class="delimiter">&quot;</span></span>
  <span class="keyword">end</span>
<span class="keyword">end</span>


puts a.test
<span class="comment"># =&gt; Singleton method on a</span>
<span class="comment"># =&gt; Instance method of class A</span>


puts b.test
<span class="comment"># =&gt; Singleton method of object b</span>
<span class="comment"># =&gt; Mixin method of module R</span>
<span class="comment"># =&gt; Mixin method of module Q</span>
<span class="comment"># =&gt; Mixin method of module P</span>
<span class="comment"># =&gt; Mixin method of module O</span>
<span class="comment"># =&gt; Instance method of class B</span>
<span class="comment"># =&gt; Mixin method of module N</span>
<span class="comment"># =&gt; Mixin method of module M</span>
<span class="comment"># =&gt; Instance method of class A</span>
</pre></td>
</tr></table>
</div>

<p>Hooray! Things work as expected. And the process can be summed up:</p>

<ol>
  <li>Singleton methods on the Eigenclass.</li>
  <li>Methods from modules on the Eigenclass, in reverse order of inclusion.</li>
  <li>Instance methods of the class.</li>
  <li>Methods from modules on the class, in reverse order of inclusion.</li>
  <li>Return to step 3 for the superclass of the current class.</li>
</ol>
]]></content>
  </entry>
  
</feed>
