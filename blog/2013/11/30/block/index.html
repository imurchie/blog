
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Blocks, Procs, Lambdas, Methods - Random Thoughts</title>
  <meta name="author" content="Isaac Murchie">

  
  <meta name="description" content="Ruby has a number of ways to create callable bits of code: blocks, procs, lambdas, and methods. Blocks Blocks are the oddball in that they are not &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://imurchie.github.io/blog/blog/2013/11/30/block">
  <link href="/blog/favicon.png" rel="icon">
  <link href="/blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/blog/atom.xml" rel="alternate" title="Random Thoughts" type="application/atom+xml">
  <script src="/blog/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/blog/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/blog/">Random Thoughts</a></h1>
  
    <h2>Codes. Sanskrits. Stuffs.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/blog/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:imurchie.github.io/blog" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/blog/">Blog</a></li>
  <li><a href="/blog/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Blocks, Procs, Lambdas, Methods</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-30T08:14:45-08:00" pubdate data-updated="true">Nov 30<span>th</span>, 2013</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Ruby has a number of ways to create callable bits of code: blocks, procs, lambdas, and methods.</p>

<!-- more -->

<p><em>Blocks</em></p>

<p>Blocks are the oddball in that they are not objects. They are anonymous bits of code that get sent to methods to be used in some way. Left to their own decides they remain anonymous:
~~~
        def block_caller
          yield
        end</p>

<pre lang="ruby"><code>    block_caller { puts "in a block" }
    # =&gt; in a block ~~~
</code></pre>
<p>Here there are no named references to the block sent in to <code>block_caller</code>, just the keyword <code>yield</code> which yields control to any block the method knows of. Outside the method there is no way to access the code in that block.</p>

<p lang="ruby">Blocks are probably the most common form of this sort of behaviour in Ruby. Within both the Ruby core and the standard library there are a miriad methods that use blocks to customize their own behaviour. So, sorting an <code>Array</code> will, on its own, be in ascending order of the. But it can take a block, the result of running of which will determine how the sorting occurs:
~~~
        irb(main):011:0&gt; array = [3, 4, 2, 5, 1]
        =&gt; [3, 4, 2, 5, 1]
        irb(main):012:0&gt; array.sort
        =&gt; [1, 2, 3, 4, 5]
        irb(main):013:0&gt; array.sort { |a, b| b &lt;=&gt; a }
        =&gt; [5, 4, 3, 2, 1]
~~~</p>
<p>Tada!</p>

<p><em>Procs</em></p>

<p><code>Proc</code>s act much like blocks, but are fullfledged objects, and can be referenced and manipulated like any other object. Moreover, blocks and <code>Proc</code>s can be interchanged while calling methods, using the <code>&amp;</code> keyword.
~~~
        def block_caller
          yield(“test”)
        end</p>

<pre lang="ruby"><code>    def proc_block_caller(&amp;prc)
      prc.call("test")
    end

    def proc_caller(prc)
      prc.call("test")
    end

    prc = Proc.new { |input| puts input }
    # or: prc = proc { |input| puts input }

    block_caller(&amp;prc)
    # =&gt; test

    proc_block_caller { |input| puts input }
    # =&gt; test

    proc_caller(prc)
    # =&gt; test ~~~
</code></pre>
<p>In the first, we send a <code>Proc</code> as a block to the method, then a block as a <code>proc</code>, and finally a <code>Proc</code> as a normal argument to the method. All three result in the same functionality.</p>

<p>Further, both blocks and <code>Proc</code>s are allocated on the heap, and so any return statement executed within them will return <em>from the context in which they are called</em>, not just from themselves:
~~~
        def yielding_method
          puts “yielding to block”
          yield
          puts “yielded to block”
        end</p>

<pre lang="ruby"><code>    yielding_method { puts "in block" }
    # =&gt; yielding to block
    # =&gt; in block
    # =&gt; yielded to block

    yielding_method { puts "in block"; return true }
    # =&gt; yielding to block
    # =&gt; in block

    # in the default scope
    Proc.new { return true }.call
    # =&gt; LocalJumpError: unexpected return
    # =&gt;    ... ~~~
</code></pre>

<p>On the same lines, neither blocks nor <code>Proc</code>s do any checking of the arguments being passed in.
~~~
        prc = Proc.new { |arg1, arg2| puts “#{arg1.inspect}, #{arg2.inspect}” }
        prc.call(“first argument”, “second argument”)
        # =&gt; “first argument”, “second argument”</p>

<pre lang="ruby"><code>    prc.call("first argument")
    # =&gt; "first argument", nil

    prc.call("first argument", "second argument", "third argument")
    # =&gt; "first argument", "second argument" ~~~
</code></pre>
<p>See <code>Lambda</code> below for more details, and a contrastive view.</p>

<p><em>Lambdas</em></p>

<p>In maths, starting with Alonzo Church (DATES?) and his <em>Lambda Calculus</em>, <em>λ</em> is used to refer to a function and the ordered list of arguments the function needs. This terminology was taken up by the creators of Lisp to refer to the same thing, in the programming realm. Indeed, John McCarthy, who developed the language in 1958, makes the ties clear in his 1960 paper on Lisp, “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I.”</p>

<p>In Ruby, Lambdas behave like methods in ways that blocks and procs don’t. The two most important aspects of this functionality are</p>

<ol lang="ruby">
  <li>
    <p>Stack memory vs. heap memory: Like full-fledged methods, Lambdas get space allocated on the call stack, rather than in the heap. In normal operation, this manifests itself in the ability of Lambdas to make explicit returns with method-like results.
~~~
        def yielding_method
          puts “yielding to block”
          yield
          puts “yielded to block”
        end</p>

    <pre><code>    l = lambda { puts "in lambda"; return true }
    # or: l = -&gt; { ... }

    yielding_method &amp;l
    # =&gt; yielding to block
    # =&gt; in lambda
    # =&gt; yielded to block ~~~
</code></pre>
  </li>
</ol>
<ol lang="ruby">
  <li>
    <p>Arity checking: Also like full-fledged methods, lambdas get checked to make sure the arguments are of the necessary types, given the parameter list.
~~~
        l = lambda { |arg1, arg2| puts “#{arg1}, #{arg2}” }
        l.call(“first argument”, “second argument”)
        # =&gt; first argument, second argument</p>

    <pre><code>    l.call("first argument")
    # -&gt; ArgumentError: wrong number of arguments (1 for 2)
    # -&gt;     ...

    l.call("first argument", "second argument", "third argument")
    # -&gt; ArgumentError: wrong number of arguments (3 for 2)
    # -&gt;     ... ~~~
</code></pre>
  </li>
</ol>
<p><code>Lambda</code>s are, however, much less commonly used in Ruby development.</p>

<p><em>Methods</em></p>

<p>The last type of callable object is the <code>Method</code>. Normally, methods are of a different sort than blocks, <code>Proc</code>s, or <code>Lambda</code>s, since they are tied to classes (even in the case of singleton methods, which are part of a singleton (or “eigen-“) class). But they can be freed from a class and passed as a callable object in their own right. Calling the <code>Object#method</code> method returns a <code>Method</code> object that can be passed around and used much like a <code>Proc</code>.
~~~
        meth = “a lowercase string”.method(:upcase)
        meth.call
        # =&gt; A LOWERCASE STRING</p>

<pre lang="ruby"><code>    # a Proc can be obtained from a Method
    prc = meth.to_proc
    prc.call
    # =&gt; A LOWERCASE STRING ~~~
</code></pre>
<p>In all, these objects (and non-objects, in the case of blocks) are part of the dynamicity of Ruby as a programming language. They are also one of the most interesting features of the language, importing as they do functional programming techniques to the object-oriented world.</p>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Isaac Murchie</span></span>

      








  


<time datetime="2013-11-30T08:14:45-08:00" pubdate data-updated="true">Nov 30<span>th</span>, 2013</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="/blog//twitter.com/share" class="twitter-share-button" data-url="http://imurchie.github.io/blog/blog/2013/11/30/block/" data-via="" data-counturl="http://imurchie.github.io/blog/blog/2013/11/30/block/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/blog/2013/11/30/string-concatenation/" title="Previous Post: String concatenation">&laquo; String concatenation</a>
      
      
        <a class="basic-alignment right" href="/blog/blog/2013/11/30/idioms/" title="Next Post: Idioms and Habits">Idioms and Habits &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/blog/2013/11/30/idioms/">Idioms and Habits</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2013/11/30/block/">Blocks, Procs, Lambdas, Methods</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2013/11/30/string-concatenation/">String Concatenation</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2013/11/30/debugging/">Debugging</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2013/11/29/coupling/">Coupling</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Isaac Murchie -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
