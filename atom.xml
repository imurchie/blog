<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Random Thoughts]]></title>
  <link href="http://imurchie.github.io/blog/atom.xml" rel="self"/>
  <link href="http://imurchie.github.io/blog/"/>
  <updated>2013-12-01T12:09:46-08:00</updated>
  <id>http://imurchie.github.io/blog/</id>
  <author>
    <name><![CDATA[Isaac Murchie]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Idioms and Habits]]></title>
    <link href="http://imurchie.github.io/blog/blog/2013/11/30/idioms/"/>
    <updated>2013-11-30T11:35:00-08:00</updated>
    <id>http://imurchie.github.io/blog/blog/2013/11/30/idioms</id>
    <content type="html"><![CDATA[<p>I am slowly to have in mind Ruby idioms for things that I would initially turn to manual techniques. The first that comes to mind is iterating over an array and a sub-array one shorter. How I would have done it:</p>

<pre lang="ruby"><code>array = [1, 2, 3, 4, 5, 6]

i = 0
array.each do |el|
  j = i + 1
  while j &lt; array.length
    # process el (or array[i]) and array[j]

    j += 1
  end

  i += 1
end
</code></pre>

<p>Which basically Ruby-ifies a C-style for-loop implementation</p>

<pre lang="ruby"><code>for(int i=0; i&lt;array.length; i++)
  for(int j=i+1; j&lt;array.length; j++)
    # process array[i] and array[j]
  end
end
</code></pre>

<p>However, Ruby can do this in a much better way, using <code lang="ruby">Array</code> and <code lang="ruby">Fixnum</code> methods:</p>

<pre lang="ruby"><code># using array indices so both sides are alike
# and the C implementation is better mirrored
array.times do |i|
  (i+1...array.length).times do |j|
    # process array[i] and array[j]
  end
end

# or with an Arrray method
array.each_with_index do |el, i|
  (i+1...array.length).times do |j|
    # process el and array[j]
  end
end
</code></pre>

<p>The benefit of the last two Ruby implementations is that the programmer no longer needs to keep track of the indices. We are, as developers, left with making the logic of the data processing rather than the machinery of iterating over it.</p>

<p>While I knew the methods, until recently they hadn’t been in the fore of my mind when I arrive at a problem needing solving. I’m sure there are many more that will eventually percolate up so that they are the go-to implementations.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Blocks, Procs, Lambdas, Methods]]></title>
    <link href="http://imurchie.github.io/blog/blog/2013/11/30/block/"/>
    <updated>2013-11-30T08:14:45-08:00</updated>
    <id>http://imurchie.github.io/blog/blog/2013/11/30/block</id>
    <content type="html"><![CDATA[<p>Ruby has a number of ways to create callable bits of code: blocks, procs, lambdas, and methods.</p>

<!-- more -->

<p><em>Blocks</em></p>

<p>Blocks are the oddball in that they are not objects. They are anonymous bits of code that get sent to methods to be used in some way. Left to their own decides they remain anonymous:
~~~
        def block_caller
          yield
        end</p>

<pre lang="ruby"><code>    block_caller { puts "in a block" }
    # =&gt; in a block ~~~
</code></pre>
<p>Here there are no named references to the block sent in to <code>block_caller</code>, just the keyword <code>yield</code> which yields control to any block the method knows of. Outside the method there is no way to access the code in that block.</p>

<p lang="ruby">Blocks are probably the most common form of this sort of behaviour in Ruby. Within both the Ruby core and the standard library there are a miriad methods that use blocks to customize their own behaviour. So, sorting an <code>Array</code> will, on its own, be in ascending order of the. But it can take a block, the result of running of which will determine how the sorting occurs:
~~~
        irb(main):011:0&gt; array = [3, 4, 2, 5, 1]
        =&gt; [3, 4, 2, 5, 1]
        irb(main):012:0&gt; array.sort
        =&gt; [1, 2, 3, 4, 5]
        irb(main):013:0&gt; array.sort { |a, b| b &lt;=&gt; a }
        =&gt; [5, 4, 3, 2, 1]
~~~</p>
<p>Tada!</p>

<p><em>Procs</em></p>

<p><code>Proc</code>s act much like blocks, but are fullfledged objects, and can be referenced and manipulated like any other object. Moreover, blocks and <code>Proc</code>s can be interchanged while calling methods, using the <code>&amp;</code> keyword.
~~~
        def block_caller
          yield(“test”)
        end</p>

<pre lang="ruby"><code>    def proc_block_caller(&amp;prc)
      prc.call("test")
    end

    def proc_caller(prc)
      prc.call("test")
    end

    prc = Proc.new { |input| puts input }
    # or: prc = proc { |input| puts input }

    block_caller(&amp;prc)
    # =&gt; test

    proc_block_caller { |input| puts input }
    # =&gt; test

    proc_caller(prc)
    # =&gt; test ~~~
</code></pre>
<p>In the first, we send a <code>Proc</code> as a block to the method, then a block as a <code>proc</code>, and finally a <code>Proc</code> as a normal argument to the method. All three result in the same functionality.</p>

<p>Further, both blocks and <code>Proc</code>s are allocated on the heap, and so any return statement executed within them will return <em>from the context in which they are called</em>, not just from themselves:
~~~
        def yielding_method
          puts “yielding to block”
          yield
          puts “yielded to block”
        end</p>

<pre lang="ruby"><code>    yielding_method { puts "in block" }
    # =&gt; yielding to block
    # =&gt; in block
    # =&gt; yielded to block

    yielding_method { puts "in block"; return true }
    # =&gt; yielding to block
    # =&gt; in block

    # in the default scope
    Proc.new { return true }.call
    # =&gt; LocalJumpError: unexpected return
    # =&gt;    ... ~~~
</code></pre>

<p>On the same lines, neither blocks nor <code>Proc</code>s do any checking of the arguments being passed in.
~~~
        prc = Proc.new { |arg1, arg2| puts “#{arg1.inspect}, #{arg2.inspect}” }
        prc.call(“first argument”, “second argument”)
        # =&gt; “first argument”, “second argument”</p>

<pre lang="ruby"><code>    prc.call("first argument")
    # =&gt; "first argument", nil

    prc.call("first argument", "second argument", "third argument")
    # =&gt; "first argument", "second argument" ~~~
</code></pre>
<p>See <code>Lambda</code> below for more details, and a contrastive view.</p>

<p><em>Lambdas</em></p>

<p>In maths, starting with Alonzo Church (DATES?) and his <em>Lambda Calculus</em>, <em>λ</em> is used to refer to a function and the ordered list of arguments the function needs. This terminology was taken up by the creators of Lisp to refer to the same thing, in the programming realm. Indeed, John McCarthy, who developed the language in 1958, makes the ties clear in his 1960 paper on Lisp, “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I.”</p>

<p>In Ruby, Lambdas behave like methods in ways that blocks and procs don’t. The two most important aspects of this functionality are</p>

<ol lang="ruby">
  <li>
    <p>Stack memory vs. heap memory: Like full-fledged methods, Lambdas get space allocated on the call stack, rather than in the heap. In normal operation, this manifests itself in the ability of Lambdas to make explicit returns with method-like results.
~~~
        def yielding_method
          puts “yielding to block”
          yield
          puts “yielded to block”
        end</p>

    <pre><code>    l = lambda { puts "in lambda"; return true }
    # or: l = -&gt; { ... }

    yielding_method &amp;l
    # =&gt; yielding to block
    # =&gt; in lambda
    # =&gt; yielded to block ~~~
</code></pre>
  </li>
</ol>
<ol lang="ruby">
  <li>
    <p>Arity checking: Also like full-fledged methods, lambdas get checked to make sure the arguments are of the necessary types, given the parameter list.
~~~
        l = lambda { |arg1, arg2| puts “#{arg1}, #{arg2}” }
        l.call(“first argument”, “second argument”)
        # =&gt; first argument, second argument</p>

    <pre><code>    l.call("first argument")
    # -&gt; ArgumentError: wrong number of arguments (1 for 2)
    # -&gt;     ...

    l.call("first argument", "second argument", "third argument")
    # -&gt; ArgumentError: wrong number of arguments (3 for 2)
    # -&gt;     ... ~~~
</code></pre>
  </li>
</ol>
<p><code>Lambda</code>s are, however, much less commonly used in Ruby development.</p>

<p><em>Methods</em></p>

<p>The last type of callable object is the <code>Method</code>. Normally, methods are of a different sort than blocks, <code>Proc</code>s, or <code>Lambda</code>s, since they are tied to classes (even in the case of singleton methods, which are part of a singleton (or “eigen-“) class). But they can be freed from a class and passed as a callable object in their own right. Calling the <code>Object#method</code> method returns a <code>Method</code> object that can be passed around and used much like a <code>Proc</code>.
~~~
        meth = “a lowercase string”.method(:upcase)
        meth.call
        # =&gt; A LOWERCASE STRING</p>

<pre lang="ruby"><code>    # a Proc can be obtained from a Method
    prc = meth.to_proc
    prc.call
    # =&gt; A LOWERCASE STRING ~~~
</code></pre>
<p>In all, these objects (and non-objects, in the case of blocks) are part of the dynamicity of Ruby as a programming language. They are also one of the most interesting features of the language, importing as they do functional programming techniques to the object-oriented world.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String Concatenation]]></title>
    <link href="http://imurchie.github.io/blog/blog/2013/11/30/string-concatenation/"/>
    <updated>2013-11-30T08:08:28-08:00</updated>
    <id>http://imurchie.github.io/blog/blog/2013/11/30/string-concatenation</id>
    <content type="html"><![CDATA[<p lang="ruby">The literature says that <code>String#&lt;&lt;</code> is preferable to <code>String#+</code>. Why? One metric is speed. The following Ruby code snippet:
~~~
        Benchmark.bm do |b|
          b.report(“+:  “) do
            string = “test”
            100_000.times { string += “another” }
          end
          b.report(“«: “) do
            string = “test”
            100_000.times { string « “another” }
          end
        end
~~~</p>
<p>Yields the following data:
~~~
           user     system      total        real
        +:    8.960000   2.750000  11.710000 ( 11.735344)
        «:   0.020000   0.000000   0.020000 (  0.019966)
~~~
So it appears that concatenation with the <code>&lt;&lt;</code> method is much faster. (As a side note, <code>String#concat</code> and <code>String#&lt;&lt;</code> are aliases.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging]]></title>
    <link href="http://imurchie.github.io/blog/blog/2013/11/30/debugging/"/>
    <updated>2013-11-30T08:01:53-08:00</updated>
    <id>http://imurchie.github.io/blog/blog/2013/11/30/debugging</id>
    <content type="html"><![CDATA[<blockquote>
  <p>“Everyone knows that debugging is twice as hard as writing a program in the first place. So if you’re as clever as you can be when you write it, how will you ever debug it?”</p>
</blockquote>

<p>— Brian Kernighan (Elements of Programming Style, Chapter 2).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coupling]]></title>
    <link href="http://imurchie.github.io/blog/blog/2013/11/29/coupling/"/>
    <updated>2013-11-29T09:00:43-08:00</updated>
    <id>http://imurchie.github.io/blog/blog/2013/11/29/coupling</id>
    <content type="html"><![CDATA[<p>One of the problems encountered in designing systems is keeping the <em>coupling</em> between components loose. That is, making each object only know as much about the others as it absolutely needs.</p>

<p>Jim Weirich gave a talk at the <em>Distill</em> conference on the topic of “connascence,” or the coming-into-being-together. His idea was that there are two related phenomena in software design: <em>coupling</em> and <em>coherence</em>.</p>

<p><em>Coupling</em> occurs between two pieces of software (from separate systems talking to each other all the way down to two objects within the same program). If two elements <code>A</code> and <code>B</code> are <em>coupled</em>, changing <code>A</code> forces a change in <code>B</code>, and (likely) vice versa.</p>

<!-- more -->

<p>The former is bad, linking two different elements together, which the latter is good, tying everything within a single element into a cohesive unit.</p>

<p>The two nicely sum up the values inculcated in the curriculum, that classes ought to model one thing and one thing only, with all the state and behaviour being ordered toward that thing. The same principle applies to methods, which are short and do a single thing.</p>

<p>On the other side of the design of classes and methods, which are coherent to the object being modelled, only those <em>currently</em> necessary should be exposed in the interface. Many methods that are in a class have no reason to be publicly available.</p>

<p>Weirich enumerated nine types of connascence, depending on how the two elements are related:
1.  Name: two elements refer to each other by name
2.  Position: (e.g., ordering of arrays, parameter lists)
3.  Meaning: must both agree on meaning of some data
4.  Algorithm: two components agree on algorithms (e.g., checksums)
5.  Type: agree on the type of elements
6.  Execution: order of steps might be required
7.  Timing: elements related by some time condition (e.g., race conditions, timeout, etc.)
8.  Value: values related by constraints (e.g., three sides to a triangle)
9.  Identity: sharing an object
In all these cases, when the related elements are in different classes (and often within the same class), this is moving toward bad (though some are unavoidable… things need to be named and need to be referred to by those names). The first five are <em>static</em>, depending only on how they are declared and defined. The last four are dynamic, coming about in the running of the software.</p>

<p lang="ruby">Some major sources of coupling include parameter lists that are more than 2–3 elements long,
~~~
        def many_parametered_method(name, date, signup_date, mothers_maiden_name)
~~~</p>
<p>Which is easily misused, and difficult to change. This is connascence of Name, Position, Meaning, and Type. However, changing this to an associative array makes it easier for callers to get things right,
~~~
        def method(params = {})</p>

<pre lang="ruby"><code>    method({ name: "Isaac", date: "18/9/13", signup_date: "18/9/13", mothers_maiden_name: "Something" }) ~~~
</code></pre>
<p>Now the order doesn’t matter, though we still have coupling of name (is it <code>name</code> or <code>fullname</code>).</p>

<p>In a different realm, there is a similar concept called “supervenience”, such that:</p>

<blockquote>
  <p>“A set of properties A supervenes upon another set B just in case no two things can differ with respect to A-properties without also differing with respect to their B-properties.”
<a href="http://plato.stanford.edu/entries/supervenience/"><em>Stanford Encyclopedia of Philosophy</em></a></p>
</blockquote>

<p>I’ll just leave that out there for myself to think about.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design]]></title>
    <link href="http://imurchie.github.io/blog/blog/2013/11/29/design/"/>
    <updated>2013-11-29T09:00:15-08:00</updated>
    <id>http://imurchie.github.io/blog/blog/2013/11/29/design</id>
    <content type="html"><![CDATA[<p>Russ Olson, in his book <em>Design Patterns in Ruby</em> (an abridged “Gang of Four” book, with implementations in Ruby), he lays out the principles that underly his approach, and which mesh well with the curriculum:</p>

<blockquote>
  <p>For me, these ideas boil down to four points:
1.  Separate out the things that change from those that stay the same.
2.  Program to an interface, not an implementation.
3.  Prefer composition over inheritance.
4.  Delegate, delegate, delegate.
To These, I would like to add one idea that is not really mentioned in _Design Patterns, but that guides much of my own approach to building programs:
5.  You ain’t gonna need it.</p>
</blockquote>

<!-- more -->

<p>The first four are identical to the guiding principles of the “Gang of Four.” In order to make robust software systems the places where things change should be identifiable, and ideally minimized (particularly in their public interface, so making a change does not effect, domino-like, other parts of the system). This relates directly to the idea of an interface (not of the C++/Java sort): the public facing parts of the class (or other object) should be as stable as possible, and it is more important to keep them functioning correctly. The implementation matters less, and what implementation is used might be decided using other considerations (e.g., efficiency, stability, auditability).</p>

<p>The third part of this is an interesting one, and the subject of a recent blog post by <a href="http://words.steveklabnik.com/">Steve Klabnik</a>, <a href="http://words.steveklabnik.com/beware-subclassing-ruby-core-classes">“Beware subclassing Ruby core classes”</a>. Ruby only supports single inheritance, so inheriting from one class precludes doing so with another class. However, the central problem of inheritance is the tight coupling that comes about between the class and its superclass. Change the parent and the functionality of the child is suspect.</p>

<p>The fourth point is just passing the responsibility to something else. This is key to the idea of <em>D.R.Y</em> (“Don’t Repeat Yourself”), since two elements that do the same thing can delegate to a third that actually does it.</p>

<p>The final part of Olson’s discussion is part of our curriculum directly: If it is not necessary at this time, don’t build it. Speculation almost never gets it right. I’m reminded of Cory Doctorow’s position on science fiction writers:
&gt; “I’m of the opinion that science fiction writers suck at predicting the future. We mostly go around describing the present in futuristic clothes - (such as) Mary Shelley, Bill Gibson, and many others.”
&gt; <a href="http://3degree.ecu.edu.au/articles/1378">“Where is my flying car”</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Symbols]]></title>
    <link href="http://imurchie.github.io/blog/blog/2013/11/28/ruby-symbols/"/>
    <updated>2013-11-28T21:34:40-08:00</updated>
    <id>http://imurchie.github.io/blog/blog/2013/11/28/ruby-symbols</id>
    <content type="html"><![CDATA[<p>Ruby <code>Symbol</code>s are interesting things, conceptually straddling the line separating themselves from <code>String</code>s. They do not, however, have any content of their own. They are, basically, the logical endpoint of the <em>nominitive</em> case in case-based grammars.</p>

<p>As we know from the Sanskrit grammarians,</p>

<blockquote>
  prātipadikārthaliṅgaparimāṇavacanamātre prathamā
  (Pā. 2.3.46)
</blockquote>

<p>Which is to say, the “first,” or nominative, case is used in the sense of merely (<em>mātre</em>) the lexical meaning of the nominal base (<em>prātipadikārtha</em>), its gender (<em>liṅga</em>), its measure (<em>parimāṇa</em>), or its number (<em>vacana</em>)</p>

<!-- more -->

<p>So the nominitive, in Sanskrit grammar, conveys most prominently (grammatical <em>dvandva_s functioning as ordered-by-preference) the bare meaning of the lexical stem. And this is what Ruby <code>Symbol</code>s do! They convey information only insofar as they are named usefully. Their main purpose is as… well… _symbols</em>.</p>

<p>One thing of note is that within a Ruby interpretter, there is only ever <em>one</em> copy of any given <code>Symbol</code>. So checking for equality is fast, the equality being directly testable through the <code>Symbol</code>s identity.</p>

<p lang="ruby">So, for instance, if we have a <code>Hash</code> object that has <code>String</code> keys,
~~~
person = {
  “name”    =&gt; “Isaac”,
  “tumblr”  =&gt; “isaac-codes”
}
~~~</p>
<p lang="ruby">When we access an element from the <code>Hash</code>,
~~~
        name = person[“name”]
~~~</p>
<p>The operation needs to check the keys for the <code>String</code> “name”, which means checking that the first letter is “n”, the second “a” etc. etc. ad nauseum.</p>

<p lang="ruby">If, on the other hand, we use <code>Symbols</code> for the keys,
~~~
        person = {
          name:   “Isaac”,
          tumblr: “isaac-codes”
        }
~~~</p>
<p lang="ruby">When we access an element,
~~~
        name = person[:name]
~~~</p>
<p lang="cpp">The equality operation merely tests whether the two <code>Symbol</code>s occupy the same position in memory! The <em>C</em> code for the operation is simple,
~~~
        static VALUE
        sym_equal(VALUE sym1, VALUE sym2) {
          if (sym1 == sym2) return Qtrue;
          return Qfalse;
        }
~~~</p>
<p>We can see, therefore that comparison is O(1) for the <code>Symbol</code>!</p>

<p>This simplicty, however, leads to one major potential problem in the use of <code>Symbol</code>s, as noted in the curriculum. Since <code>Symbol</code>s aren’t referenced by anything, there is no indicator of their going “out of scope,” and so no possibility for the Garbage Collector to release them from memory. So every <code>Symbol</code> created in the course of running a Ruby script continues to exist in memory. They are, therefore, unsuitable for “situations where you could have an unbounded number of unique
symbol values” (http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/164890).</p>

<p>The practical take-away of this is to manage well what is being converted into a symbol. Repeatedly used <code>Hash</code> keys, like those to the Rack/Rails <code>params</code> hash, are fine. But converting <em>ad hoc</em> <code>String</code>s into <code>Symbol</code>s is asking for problems on any non-trivial system.</p>

<p lang="ruby">If, for instance, we took a user’s name and converted it to a   <code>Symbol</code> for insertion into a <code>Hash</code>,
~~~
        users = {}
        username = “Isaac”
        users[username.to_sym] = “Present”
~~~</p>
<p>And we extend the system to handle a million users, the memory usage will balloon! To illustrate,
~~~
        irb(main):001:0&gt; <code>ps -o rss= -p #{Process.pid}</code>.to_i
        =&gt; 19908
        irb(main):002:0&gt; users = {}
        =&gt; {}
        irb(main):003:0&gt; 1_000_000.times do |i|
        irb(main):004:1*   username = “user_#{i}”
        irb(main):005:1&gt;   users[username.to_sym] = true
        irb(main):006:1&gt;   end
        =&gt; 1000000
        irb(main):007:0&gt; <code>ps -o rss= -p #{Process.pid}</code>.to_i
        =&gt; 259360
        irb(main):008:0&gt; GC.start()
        =&gt; nil
        irb(main):009:0&gt; <code>ps -o rss= -p #{Process.pid}</code>.to_i
        =&gt; 259804
        irb(main):010:0&gt; users = nil
        =&gt; nil
        irb(main):011:0&gt; GC.start()
        =&gt; nil
        irb(main):012:0&gt; <code>ps -o rss= -p #{Process.pid}</code>.to_i
        =&gt; 259828
~~~
Even after garbage collecting, there is no decrease in memory usage. (On a side note, there are issues within the field of garbage collection to be kept in mind. Particularly, it seems that no system is actually particularly likely to free any memory. See, for instance, http://stackoverflow.com/questions/1119134/how-do-malloc-and-free-work/5532547#5532547.)</p>

]]></content>
  </entry>
  
</feed>
